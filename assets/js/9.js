(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{46:function(e,t,a){"use strict";a.r(t);var s={},n=a(1),r=Object(n.a)(s,function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("MpLayoutManager",[a("div",{staticClass:"page-content"},[a("h1",{attrs:{id:"internals"}},[a("router-link",{staticClass:"header-anchor",attrs:{to:"#internals","aria-hidden":"true"}},[e._v("#")]),e._v(" Internals")],1),e._v(" "),a("p",[e._v("If you want to know how "),a("em",[e._v("miniPress")]),e._v(" works internally – this guide is for you.")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("A word of caution:")]),e._v("\nThe internals change very frequently as I learn new things. Also – my understanding might be incorrect.")])]),e._v(" "),a("h2",{attrs:{id:"how-pages-come-to-life"}},[a("router-link",{staticClass:"header-anchor",attrs:{to:"#how-pages-come-to-life","aria-hidden":"true"}},[e._v("#")]),e._v(" How Pages come to Life")],1),e._v(" "),a("p",[e._v("Let’s assume that there is a directory called "),a("code",[e._v("pages/")]),e._v(", which contains all of your Markdown files. Each file represents a page. When "),a("em",[e._v("miniPress")]),e._v(" is started, it looks in that directory and finds all Markdown files. It makes a note of each file and basically just renders the Markdown file using it’s custom Markdown setup. So basically this is what happens ("),a("em",[e._v("pseudocode")]),e._v("):")]),e._v(" "),a("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[a("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[a("code",{pre:!0,attrs:{class:"language-js"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" paths "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("findPagesIn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'pages/'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\npaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("path")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Page")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")])])])]),a("p",[e._v("The Markdown pipeline is setup in a "),a("strong",[e._v("special way")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("render()")]),e._v(" does some preprocessing (extract frontmatter, …) and the renders the page by basically invoking each Markdown(-it)-plugin.")]),e._v(" "),a("li",[e._v("Each Markdown plugin knows which "),a("code",[e._v("Page")]),e._v("-instance it operates on.")]),e._v(" "),a("li",[e._v("Each Markdown plugin does it’s job and then simply sets properties on the page instance as needed.")]),e._v(" "),a("li",[e._v("For example – the headings plugin sets the "),a("code",[e._v("headings")]),e._v("-property on the page instance.")])]),e._v(" "),a("p",[e._v("After the "),a("em",[e._v("initial")]),e._v(" render process the "),a("code",[e._v("Page")]),e._v("-instances are pre-populated with all the data we need.")])])])},[],!1,null,null,null);t.default=r.exports}}]);