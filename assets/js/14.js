(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{56:function(a,s,t){"use strict";t.r(s);var n={layout:"default"},e=t(0),o=function(a){var s=a.options.beforeCreate||[];a.options.beforeCreate=[function(){this.$page={key:"ca11f630",path:"/internals",file:{relative:"internals.md",absolute:"/Users/d069408/ChristianKienle/minpress/docs/pages/internals.md"},content:'<h1 id="internals"><router-link class="header-anchor" to="#internals" aria-hidden="true">#</router-link> Internals</h1>\n<p>If you want to know how <em>miniPress</em> works internally – this guide is for you.</p>\n<blockquote>\n<p><strong>A word of caution:</strong>\nThe internals change very frequently as I learn new things. Also – my understanding might be incorrect.</p>\n</blockquote>\n<h2 id="how-pages-come-to-life"><router-link class="header-anchor" to="#how-pages-come-to-life" aria-hidden="true">#</router-link> How Pages come to Life</h2>\n<p>Let’s assume that there is a directory called <code>pages/</code>, which contains all of your Markdown files. Each file represents a page. When <em>miniPress</em> is started, it looks in that directory and finds all Markdown files. It makes a note of each file and basically just renders the Markdown file using it’s custom Markdown setup. So basically this is what happens (<em>pseudocode</em>):</p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js"><span class="token keyword">const</span> paths <span class="token operator">=</span> <span class="token function">findPagesIn</span><span class="token punctuation">(</span><span class="token string">\'pages/\'</span><span class="token punctuation">)</span>\npaths<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">path</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p>The Markdown pipeline is setup in a <strong>special way</strong>:</p>\n<ul>\n<li><code>render()</code> does some preprocessing (extract frontmatter, …) and the renders the page by basically invoking each Markdown(-it)-plugin.</li>\n<li>Each Markdown plugin knows which <code>Page</code>-instance it operates on.</li>\n<li>Each Markdown plugin does it’s job and then simply sets properties on the page instance as needed.</li>\n<li>For example – the headings plugin sets the <code>headings</code>-property on the page instance.</li>\n</ul>\n<p>After the <em>initial</em> render process the <code>Page</code>-instances are pre-populated with all the data we need.</p>\n<h2 id="learnings"><router-link class="header-anchor" to="#learnings" aria-hidden="true">#</router-link> Learnings</h2>\n<h3 id="plugintheme-api"><router-link class="header-anchor" to="#plugintheme-api" aria-hidden="true">#</router-link> Plugin/Theme-API</h3>\n<p>Originally I wanted to have a plugin-/theme-API like plugins in Rollup are done:</p>\n<p><strong>Custom Theme:</strong></p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* my theme implementation goes here */</span>\n<span class="token punctuation">}</span></code></pre></div><p><strong>Theme Consumer:</strong></p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js"><span class="token keyword">const</span> CustomTheme <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'my-custom-theme\'</span><span class="token punctuation">)</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  theme<span class="token punctuation">:</span> CustomTheme\n<span class="token punctuation">}</span></code></pre></div><p>However, this has one big disadvantage: <em>miniPress</em> no longer knows the location of <code>CustomTheme</code> in the file system. This means that it cannot apply certain conventions for example automatically registering components found in <code>components/</code>. Probably that is why <em>VuePress</em> requires you to specify plugins by name. It is also possible to pass <em>VuePress</em> a function as a plugin but I have no idea how they do it.</p>\n<h2 id="asyncdata"><router-link class="header-anchor" to="#asyncdata" aria-hidden="true">#</router-link> asyncData</h2>\n<p>Two things:</p>\n<ol>\n<li>First, I will describe how nuxt supports <code>asyncData</code> and then</li>\n<li>I will describe how it works in miniPress</li>\n</ol>\n<p>Let’s assume you have a page that looks like this:</p>\n<div class="minipress-highlight" v-pre="" data-lang="markup"><pre class="minipress-highlight-code language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{firstname}} – {{lastname}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> fetchLastName <span class="token keyword">from</span> <span class="token string">\'./fetch-last-name\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">data</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>firstName<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">asyncData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// &lt; returns a promise that resolves to:</span>\n    <span class="token comment">// { lastName: \'Borg\' } (or some other last name)</span>\n    <span class="token keyword">return</span> <span class="token function">fetchLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre></div><p>Now the user navigates to this page. Then <code>asyncData</code> is called on the server side and not again on the client. <code>asyncData</code> is called on the client for every page visited after the first one. The intention is probably to have a fast first page load and then the client takes over the control of <code>asyncData</code> for all subsequent site naviations.</p>\n<p>Note: Executing <code>nuxt generate</code> causes <code>asyncData</code> to be executed for each page (that does not have a dynamic route). Each <code>asyncData</code> is made part of the corresponding page bundle. But this bundled <code>asyncData</code> is only used for the initial page load (even for statically built sites). This may be what I want – or it may not be what I want. Where it breaks down is in cases where <code>asyncData</code> truly returns “static” data.</p>\n<p>This is how <code>asyncData</code> looks in miniPress:</p>\n<div class="minipress-highlight" v-pre="" data-lang="markup"><pre class="minipress-highlight-code language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{firstname}} – {{lastname}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> fetchLastName <span class="token keyword">from</span> <span class="token string">\'./fetch-last-name\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">data</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>firstName<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">asyncData</span><span class="token punctuation">(</span><span class="token parameter">asyncDataSSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>asyncDataSSR<span class="token punctuation">.</span>lastName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> asyncDataSSR\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">fetchLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre></div><p><em>miniPress</em> calls <code>asyncData</code> twice. ALWAYS. Once on the server and the again on the client. The <code>asyncDataSSR</code> argument contains a copy of what has been generated during SSR. This can be <code>{}</code> in case <code>asyncData</code> is currently executed on the server. In other cases it is just whatever <code>asyncData</code> returned during SSR. This allows you to check the contents of <code>asyncDataSSR</code>. In the case above I check whether or not it contains a <code>lastName</code>. If it does <code>asyncDataSSR</code> is good enough for my use case and I simply return <code>asyncDataSSR</code>. If it does not contain <code>lastName</code> I am fetching the last name from the backend.</p>\n<ul>\n<li>During Development miniPress initially sets <code>asyncDataSSR</code> to <code>{}</code> (when not disabled with <code>--keep-cache</code>) for every page. <code>asyncData</code> is called lazily – once you visit the corresponding page.</li>\n<li>When building a static version of the site <code>asyncData</code> is invoked for each page and also bundled with each page so that subsequent invokations come with the <code>asyncDataSSR</code> argument.</li>\n</ul>\n',contentType:"md",headings:[{text:"Internals",slug:"internals",level:1},{text:"How Pages come to Life",slug:"how-pages-come-to-life",level:2},{text:"Learnings",slug:"learnings",level:2},{text:"Plugin/Theme-API",slug:"plugintheme-api",level:3},{text:"asyncData",slug:"asyncdata",level:2}],regularPath:"/internals.html",frontmatter:{},attributes:{}}}].concat(s)},p=Object(e.a)(n,(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{staticClass:"minipress-content"},[t("h1",{attrs:{id:"internals"}},[t("router-link",{staticClass:"header-anchor",attrs:{to:"#internals","aria-hidden":"true"}},[a._v("#")]),a._v(" Internals")],1),a._v(" "),a._m(0),a._v(" "),a._m(1),a._v(" "),t("h2",{attrs:{id:"how-pages-come-to-life"}},[t("router-link",{staticClass:"header-anchor",attrs:{to:"#how-pages-come-to-life","aria-hidden":"true"}},[a._v("#")]),a._v(" How Pages come to Life")],1),a._v(" "),a._m(2),a._v(" "),a._m(3),a._m(4),a._v(" "),a._m(5),a._v(" "),a._m(6),a._v(" "),t("h2",{attrs:{id:"learnings"}},[t("router-link",{staticClass:"header-anchor",attrs:{to:"#learnings","aria-hidden":"true"}},[a._v("#")]),a._v(" Learnings")],1),a._v(" "),t("h3",{attrs:{id:"plugintheme-api"}},[t("router-link",{staticClass:"header-anchor",attrs:{to:"#plugintheme-api","aria-hidden":"true"}},[a._v("#")]),a._v(" Plugin/Theme-API")],1),a._v(" "),t("p",[a._v("Originally I wanted to have a plugin-/theme-API like plugins in Rollup are done:")]),a._v(" "),a._m(7),a._v(" "),a._m(8),a._m(9),a._v(" "),a._m(10),a._m(11),a._v(" "),t("h2",{attrs:{id:"asyncdata"}},[t("router-link",{staticClass:"header-anchor",attrs:{to:"#asyncdata","aria-hidden":"true"}},[a._v("#")]),a._v(" asyncData")],1),a._v(" "),t("p",[a._v("Two things:")]),a._v(" "),a._m(12),a._v(" "),t("p",[a._v("Let’s assume you have a page that looks like this:")]),a._v(" "),a._m(13),a._m(14),a._v(" "),a._m(15),a._v(" "),a._m(16),a._v(" "),a._m(17),a._m(18),a._v(" "),a._m(19)])}),[function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("If you want to know how "),s("em",[this._v("miniPress")]),this._v(" works internally – this guide is for you.")])},function(){var a=this.$createElement,s=this._self._c||a;return s("blockquote",[s("p",[s("strong",[this._v("A word of caution:")]),this._v("\nThe internals change very frequently as I learn new things. Also – my understanding might be incorrect.")])])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("Let’s assume that there is a directory called "),s("code",[this._v("pages/")]),this._v(", which contains all of your Markdown files. Each file represents a page. When "),s("em",[this._v("miniPress")]),this._v(" is started, it looks in that directory and finds all Markdown files. It makes a note of each file and basically just renders the Markdown file using it’s custom Markdown setup. So basically this is what happens ("),s("em",[this._v("pseudocode")]),this._v("):")])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[t("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[t("code",{pre:!0,attrs:{class:"language-js"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" paths "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("findPagesIn")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'pages/'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\npaths"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("forEach")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("path")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Page")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("path"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("render")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")])])])])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("The Markdown pipeline is setup in a "),s("strong",[this._v("special way")]),this._v(":")])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ul",[t("li",[t("code",[a._v("render()")]),a._v(" does some preprocessing (extract frontmatter, …) and the renders the page by basically invoking each Markdown(-it)-plugin.")]),a._v(" "),t("li",[a._v("Each Markdown plugin knows which "),t("code",[a._v("Page")]),a._v("-instance it operates on.")]),a._v(" "),t("li",[a._v("Each Markdown plugin does it’s job and then simply sets properties on the page instance as needed.")]),a._v(" "),t("li",[a._v("For example – the headings plugin sets the "),t("code",[a._v("headings")]),a._v("-property on the page instance.")])])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("After the "),s("em",[this._v("initial")]),this._v(" render process the "),s("code",[this._v("Page")]),this._v("-instances are pre-populated with all the data we need.")])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[s("strong",[this._v("Custom Theme:")])])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[t("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[t("code",{pre:!0,attrs:{class:"language-js"}},[a._v("module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* my theme implementation goes here */")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])])])])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[s("strong",[this._v("Theme Consumer:")])])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[t("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[t("code",{pre:!0,attrs:{class:"language-js"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" CustomTheme "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'my-custom-theme'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nmodule"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  theme"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" CustomTheme\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])])])])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("p",[a._v("However, this has one big disadvantage: "),t("em",[a._v("miniPress")]),a._v(" no longer knows the location of "),t("code",[a._v("CustomTheme")]),a._v(" in the file system. This means that it cannot apply certain conventions for example automatically registering components found in "),t("code",[a._v("components/")]),a._v(". Probably that is why "),t("em",[a._v("VuePress")]),a._v(" requires you to specify plugins by name. It is also possible to pass "),t("em",[a._v("VuePress")]),a._v(" a function as a plugin but I have no idea how they do it.")])},function(){var a=this.$createElement,s=this._self._c||a;return s("ol",[s("li",[this._v("First, I will describe how nuxt supports "),s("code",[this._v("asyncData")]),this._v(" and then")]),this._v(" "),s("li",[this._v("I will describe how it works in miniPress")])])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"markup"}},[t("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-markup"}},[t("code",{pre:!0,attrs:{class:"language-markup"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("template")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("{{firstname}} – {{lastname}}"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("template")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("script")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token script"}},[t("span",{pre:!0,attrs:{class:"token language-javascript"}},[a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" fetchLastName "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'./fetch-last-name'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("data")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("firstName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("asyncData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// < returns a promise that resolves to:")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// { lastName: 'Borg' } (or some other last name)")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("fetchLastName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("script")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])])])])])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("Now the user navigates to this page. Then "),s("code",[this._v("asyncData")]),this._v(" is called on the server side and not again on the client. "),s("code",[this._v("asyncData")]),this._v(" is called on the client for every page visited after the first one. The intention is probably to have a fast first page load and then the client takes over the control of "),s("code",[this._v("asyncData")]),this._v(" for all subsequent site naviations.")])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("p",[a._v("Note: Executing "),t("code",[a._v("nuxt generate")]),a._v(" causes "),t("code",[a._v("asyncData")]),a._v(" to be executed for each page (that does not have a dynamic route). Each "),t("code",[a._v("asyncData")]),a._v(" is made part of the corresponding page bundle. But this bundled "),t("code",[a._v("asyncData")]),a._v(" is only used for the initial page load (even for statically built sites). This may be what I want – or it may not be what I want. Where it breaks down is in cases where "),t("code",[a._v("asyncData")]),a._v(" truly returns “static” data.")])},function(){var a=this.$createElement,s=this._self._c||a;return s("p",[this._v("This is how "),s("code",[this._v("asyncData")]),this._v(" looks in miniPress:")])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"markup"}},[t("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-markup"}},[t("code",{pre:!0,attrs:{class:"language-markup"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("template")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("{{firstname}} – {{lastname}}"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("div")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("template")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("script")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token script"}},[t("span",{pre:!0,attrs:{class:"token language-javascript"}},[a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" fetchLastName "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'./fetch-last-name'")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("data")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("firstName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("asyncData")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("asyncDataSSR")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("asyncDataSSR"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lastName "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" asyncDataSSR\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("fetchLastName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("script")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])])])])])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("p",[t("em",[a._v("miniPress")]),a._v(" calls "),t("code",[a._v("asyncData")]),a._v(" twice. ALWAYS. Once on the server and the again on the client. The "),t("code",[a._v("asyncDataSSR")]),a._v(" argument contains a copy of what has been generated during SSR. This can be "),t("code",[a._v("{}")]),a._v(" in case "),t("code",[a._v("asyncData")]),a._v(" is currently executed on the server. In other cases it is just whatever "),t("code",[a._v("asyncData")]),a._v(" returned during SSR. This allows you to check the contents of "),t("code",[a._v("asyncDataSSR")]),a._v(". In the case above I check whether or not it contains a "),t("code",[a._v("lastName")]),a._v(". If it does "),t("code",[a._v("asyncDataSSR")]),a._v(" is good enough for my use case and I simply return "),t("code",[a._v("asyncDataSSR")]),a._v(". If it does not contain "),t("code",[a._v("lastName")]),a._v(" I am fetching the last name from the backend.")])},function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ul",[t("li",[a._v("During Development miniPress initially sets "),t("code",[a._v("asyncDataSSR")]),a._v(" to "),t("code",[a._v("{}")]),a._v(" (when not disabled with "),t("code",[a._v("--keep-cache")]),a._v(") for every page. "),t("code",[a._v("asyncData")]),a._v(" is called lazily – once you visit the corresponding page.")]),a._v(" "),t("li",[a._v("When building a static version of the site "),t("code",[a._v("asyncData")]),a._v(" is invoked for each page and also bundled with each page so that subsequent invokations come with the "),t("code",[a._v("asyncDataSSR")]),a._v(" argument.")])])}],!1,null,null,null);"function"==typeof o&&o(p);s.default=p.exports}}]);