(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{43:function(a,s,n){"use strict";n.r(s);var t={layout:"default"},e=n(0),o=function(a){var s=a.options.beforeCreate||[];a.options.beforeCreate=[function(){this.$page={key:"ca11f630",path:"/internals",file:{relative:"internals.md",absolute:"/Users/d069408/ChristianKienle/minpress/docs/pages/internals.md"},content:'<h1 id="internals"><router-link class="header-anchor" to="#internals" aria-hidden="true">#</router-link> Internals</h1>\n<p>If you want to know how <em>miniPress</em> works internally – this guide is for you.</p>\n<blockquote>\n<p><strong>A word of caution:</strong>\nThe internals change very frequently as I learn new things. Also – my understanding might be incorrect.</p>\n</blockquote>\n<h2 id="how-pages-come-to-life"><router-link class="header-anchor" to="#how-pages-come-to-life" aria-hidden="true">#</router-link> How Pages come to Life</h2>\n<p>Let’s assume that there is a directory called <code>pages/</code>, which contains all of your Markdown files. Each file represents a page. When <em>miniPress</em> is started, it looks in that directory and finds all Markdown files. It makes a note of each file and basically just renders the Markdown file using it’s custom Markdown setup. So basically this is what happens (<em>pseudocode</em>):</p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js"><span class="token keyword">const</span> paths <span class="token operator">=</span> <span class="token function">findPagesIn</span><span class="token punctuation">(</span><span class="token string">\'pages/\'</span><span class="token punctuation">)</span>\npaths<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">path</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></div><p>The Markdown pipeline is setup in a <strong>special way</strong>:</p>\n<ul>\n<li><code>render()</code> does some preprocessing (extract frontmatter, …) and the renders the page by basically invoking each Markdown(-it)-plugin.</li>\n<li>Each Markdown plugin knows which <code>Page</code>-instance it operates on.</li>\n<li>Each Markdown plugin does it’s job and then simply sets properties on the page instance as needed.</li>\n<li>For example – the headings plugin sets the <code>headings</code>-property on the page instance.</li>\n</ul>\n<p>After the <em>initial</em> render process the <code>Page</code>-instances are pre-populated with all the data we need.</p>\n<h2 id="learnings"><router-link class="header-anchor" to="#learnings" aria-hidden="true">#</router-link> Learnings</h2>\n<h3 id="plugintheme-api"><router-link class="header-anchor" to="#plugintheme-api" aria-hidden="true">#</router-link> Plugin/Theme-API</h3>\n<p>Originally I wanted to have a plugin-/theme-API like plugins in Rollup are done:</p>\n<p><strong>Custom Theme:</strong></p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* my theme implementation goes here */</span>\n<span class="token punctuation">}</span></code></pre></div><p><strong>Theme Consumer:</strong></p>\n<div class="minipress-highlight" v-pre="" data-lang="js"><pre class="minipress-highlight-code language-js"><code class="language-js"><span class="token keyword">const</span> CustomTheme <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'my-custom-theme\'</span><span class="token punctuation">)</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  theme<span class="token punctuation">:</span> CustomTheme\n<span class="token punctuation">}</span></code></pre></div><p>However, this has one big disadvantage: <em>miniPress</em> no longer knows the location of <code>CustomTheme</code> in the file system. This means that it cannot apply certain conventions for example automatically registering components found in <code>components/</code>. Probably that is why <em>VuePress</em> requires you to specify plugins by name. It is also possible to pass <em>VuePress</em> a function as a plugin but I have no idea how they do it.</p>\n<h2 id="asyncdata"><router-link class="header-anchor" to="#asyncdata" aria-hidden="true">#</router-link> asyncData</h2>\n<p>Two things:</p>\n<ol>\n<li>First, I will describe how nuxt supports <code>asyncData</code> and then</li>\n<li>I will describe how it works in miniPress</li>\n</ol>\n<p>Let’s assume you have a page that looks like this:</p>\n<div class="minipress-highlight" v-pre="" data-lang="markup"><pre class="minipress-highlight-code language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{firstname}} – {{lastname}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> fetchLastName <span class="token keyword">from</span> <span class="token string">\'./fetch-last-name\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">data</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>firstName<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">asyncData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// &lt; returns a promise that resolves to:</span>\n    <span class="token comment">// { lastName: \'Borg\' } (or some other last name)</span>\n    <span class="token keyword">return</span> <span class="token function">fetchLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre></div><p>Now the user navigates to this page. Then <code>asyncData</code> is called on the server side and not again on the client. <code>asyncData</code> is called on the client for every page visited after the first one. The intention is probably to have a fast first page load and then the client takes over the control of <code>asyncData</code> for all subsequent site naviations.</p>\n<p>Note: Executing <code>nuxt generate</code> causes <code>asyncData</code> to be executed for each page (that does not have a dynamic route). Each <code>asyncData</code> is made part of the corresponding page bundle. But this bundled <code>asyncData</code> is only used for the initial page load (even for statically built sites). This may be what I want – or it may not be what I want. Where it breaks down is in cases where <code>asyncData</code> truly returns “static” data.</p>\n<p>This is how <code>asyncData</code> looks in miniPress:</p>\n<div class="minipress-highlight" v-pre="" data-lang="markup"><pre class="minipress-highlight-code language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{firstname}} – {{lastname}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> fetchLastName <span class="token keyword">from</span> <span class="token string">\'./fetch-last-name\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">data</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>firstName<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">asyncData</span><span class="token punctuation">(</span><span class="token parameter">asyncDataSSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>asyncDataSSR<span class="token punctuation">.</span>lastName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> asyncDataSSR\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">fetchLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre></div><p><em>miniPress</em> calls <code>asyncData</code> twice. ALWAYS. Once on the server and the again on the client. The <code>asyncDataSSR</code> argument contains a copy of what has been generated during SSR. This can be <code>{}</code> in case <code>asyncData</code> is currently executed on the server. In other cases it is just whatever <code>asyncData</code> returned during SSR. This allows you to check the contents of <code>asyncDataSSR</code>. In the case above I check whether or not it contains a <code>lastName</code>. If it does <code>asyncDataSSR</code> is good enough for my use case and I simply return <code>asyncDataSSR</code>. If it does not contain <code>lastName</code> I am fetching the last name from the backend.</p>\n<ul>\n<li>During Development miniPress initially sets <code>asyncDataSSR</code> to <code>{}</code> (when not disabled with <code>--keep-cache</code>) for every page. <code>asyncData</code> is called lazily – once you visit the corresponding page.</li>\n<li>When building a static version of the site <code>asyncData</code> is invoked for each page and also bundled with each page so that subsequent invokations come with the <code>asyncDataSSR</code> argument.</li>\n</ul>\n',contentType:"md",headings:[{text:"Internals",slug:"internals",level:1},{text:"How Pages come to Life",slug:"how-pages-come-to-life",level:2},{text:"Learnings",slug:"learnings",level:2},{text:"Plugin/Theme-API",slug:"plugintheme-api",level:3},{text:"asyncData",slug:"asyncdata",level:2}],regularPath:"/internals.html",frontmatter:{},attributes:{}}}].concat(s)},p=Object(e.a)(t,(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("Layout",[n("div",[n("h1",{attrs:{id:"internals"}},[n("router-link",{staticClass:"header-anchor",attrs:{to:"#internals","aria-hidden":"true"}},[a._v("#")]),a._v(" Internals")],1),a._v(" "),n("p",[a._v("If you want to know how "),n("em",[a._v("miniPress")]),a._v(" works internally – this guide is for you.")]),a._v(" "),n("blockquote",[n("p",[n("strong",[a._v("A word of caution:")]),a._v("\nThe internals change very frequently as I learn new things. Also – my understanding might be incorrect.")])]),a._v(" "),n("h2",{attrs:{id:"how-pages-come-to-life"}},[n("router-link",{staticClass:"header-anchor",attrs:{to:"#how-pages-come-to-life","aria-hidden":"true"}},[a._v("#")]),a._v(" How Pages come to Life")],1),a._v(" "),n("p",[a._v("Let’s assume that there is a directory called "),n("code",[a._v("pages/")]),a._v(", which contains all of your Markdown files. Each file represents a page. When "),n("em",[a._v("miniPress")]),a._v(" is started, it looks in that directory and finds all Markdown files. It makes a note of each file and basically just renders the Markdown file using it’s custom Markdown setup. So basically this is what happens ("),n("em",[a._v("pseudocode")]),a._v("):")]),a._v(" "),n("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[n("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[n("code",{pre:!0,attrs:{class:"language-js"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" paths "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("findPagesIn")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'pages/'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\npaths"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("forEach")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("path")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Page")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("path"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("render")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")])])])]),n("p",[a._v("The Markdown pipeline is setup in a "),n("strong",[a._v("special way")]),a._v(":")]),a._v(" "),n("ul",[n("li",[n("code",[a._v("render()")]),a._v(" does some preprocessing (extract frontmatter, …) and the renders the page by basically invoking each Markdown(-it)-plugin.")]),a._v(" "),n("li",[a._v("Each Markdown plugin knows which "),n("code",[a._v("Page")]),a._v("-instance it operates on.")]),a._v(" "),n("li",[a._v("Each Markdown plugin does it’s job and then simply sets properties on the page instance as needed.")]),a._v(" "),n("li",[a._v("For example – the headings plugin sets the "),n("code",[a._v("headings")]),a._v("-property on the page instance.")])]),a._v(" "),n("p",[a._v("After the "),n("em",[a._v("initial")]),a._v(" render process the "),n("code",[a._v("Page")]),a._v("-instances are pre-populated with all the data we need.")]),a._v(" "),n("h2",{attrs:{id:"learnings"}},[n("router-link",{staticClass:"header-anchor",attrs:{to:"#learnings","aria-hidden":"true"}},[a._v("#")]),a._v(" Learnings")],1),a._v(" "),n("h3",{attrs:{id:"plugintheme-api"}},[n("router-link",{staticClass:"header-anchor",attrs:{to:"#plugintheme-api","aria-hidden":"true"}},[a._v("#")]),a._v(" Plugin/Theme-API")],1),a._v(" "),n("p",[a._v("Originally I wanted to have a plugin-/theme-API like plugins in Rollup are done:")]),a._v(" "),n("p",[n("strong",[a._v("Custom Theme:")])]),a._v(" "),n("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[n("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[n("code",{pre:!0,attrs:{class:"language-js"}},[a._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* my theme implementation goes here */")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])])])]),n("p",[n("strong",[a._v("Theme Consumer:")])]),a._v(" "),n("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"js"}},[n("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-js"}},[n("code",{pre:!0,attrs:{class:"language-js"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" CustomTheme "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("require")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'my-custom-theme'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nmodule"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  theme"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" CustomTheme\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")])])])]),n("p",[a._v("However, this has one big disadvantage: "),n("em",[a._v("miniPress")]),a._v(" no longer knows the location of "),n("code",[a._v("CustomTheme")]),a._v(" in the file system. This means that it cannot apply certain conventions for example automatically registering components found in "),n("code",[a._v("components/")]),a._v(". Probably that is why "),n("em",[a._v("VuePress")]),a._v(" requires you to specify plugins by name. It is also possible to pass "),n("em",[a._v("VuePress")]),a._v(" a function as a plugin but I have no idea how they do it.")]),a._v(" "),n("h2",{attrs:{id:"asyncdata"}},[n("router-link",{staticClass:"header-anchor",attrs:{to:"#asyncdata","aria-hidden":"true"}},[a._v("#")]),a._v(" asyncData")],1),a._v(" "),n("p",[a._v("Two things:")]),a._v(" "),n("ol",[n("li",[a._v("First, I will describe how nuxt supports "),n("code",[a._v("asyncData")]),a._v(" and then")]),a._v(" "),n("li",[a._v("I will describe how it works in miniPress")])]),a._v(" "),n("p",[a._v("Let’s assume you have a page that looks like this:")]),a._v(" "),n("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"markup"}},[n("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-markup"}},[n("code",{pre:!0,attrs:{class:"language-markup"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("template")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("{{firstname}} – {{lastname}}"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("template")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n\n"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("script")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),n("span",{pre:!0,attrs:{class:"token script"}},[n("span",{pre:!0,attrs:{class:"token language-javascript"}},[a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" fetchLastName "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'./fetch-last-name'")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("data")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("firstName"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("asyncData")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// < returns a promise that resolves to:")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// { lastName: 'Borg' } (or some other last name)")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("fetchLastName")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("script")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])])])])]),n("p",[a._v("Now the user navigates to this page. Then "),n("code",[a._v("asyncData")]),a._v(" is called on the server side and not again on the client. "),n("code",[a._v("asyncData")]),a._v(" is called on the client for every page visited after the first one. The intention is probably to have a fast first page load and then the client takes over the control of "),n("code",[a._v("asyncData")]),a._v(" for all subsequent site naviations.")]),a._v(" "),n("p",[a._v("Note: Executing "),n("code",[a._v("nuxt generate")]),a._v(" causes "),n("code",[a._v("asyncData")]),a._v(" to be executed for each page (that does not have a dynamic route). Each "),n("code",[a._v("asyncData")]),a._v(" is made part of the corresponding page bundle. But this bundled "),n("code",[a._v("asyncData")]),a._v(" is only used for the initial page load (even for statically built sites). This may be what I want – or it may not be what I want. Where it breaks down is in cases where "),n("code",[a._v("asyncData")]),a._v(" truly returns “static” data.")]),a._v(" "),n("p",[a._v("This is how "),n("code",[a._v("asyncData")]),a._v(" looks in miniPress:")]),a._v(" "),n("div",{pre:!0,attrs:{class:"minipress-highlight","data-lang":"markup"}},[n("pre",{pre:!0,attrs:{class:"minipress-highlight-code language-markup"}},[n("code",{pre:!0,attrs:{class:"language-markup"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("template")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("{{firstname}} – {{lastname}}"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("div")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("template")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("script")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),n("span",{pre:!0,attrs:{class:"token script"}},[n("span",{pre:!0,attrs:{class:"token language-javascript"}},[a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" fetchLastName "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'./fetch-last-name'")]),a._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("data")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("firstName"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("asyncData")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("asyncDataSSR")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("asyncDataSSR"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lastName "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" asyncDataSSR\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("fetchLastName")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token tag"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("script")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])])])])]),n("p",[n("em",[a._v("miniPress")]),a._v(" calls "),n("code",[a._v("asyncData")]),a._v(" twice. ALWAYS. Once on the server and the again on the client. The "),n("code",[a._v("asyncDataSSR")]),a._v(" argument contains a copy of what has been generated during SSR. This can be "),n("code",[a._v("{}")]),a._v(" in case "),n("code",[a._v("asyncData")]),a._v(" is currently executed on the server. In other cases it is just whatever "),n("code",[a._v("asyncData")]),a._v(" returned during SSR. This allows you to check the contents of "),n("code",[a._v("asyncDataSSR")]),a._v(". In the case above I check whether or not it contains a "),n("code",[a._v("lastName")]),a._v(". If it does "),n("code",[a._v("asyncDataSSR")]),a._v(" is good enough for my use case and I simply return "),n("code",[a._v("asyncDataSSR")]),a._v(". If it does not contain "),n("code",[a._v("lastName")]),a._v(" I am fetching the last name from the backend.")]),a._v(" "),n("ul",[n("li",[a._v("During Development miniPress initially sets "),n("code",[a._v("asyncDataSSR")]),a._v(" to "),n("code",[a._v("{}")]),a._v(" (when not disabled with "),n("code",[a._v("--keep-cache")]),a._v(") for every page. "),n("code",[a._v("asyncData")]),a._v(" is called lazily – once you visit the corresponding page.")]),a._v(" "),n("li",[a._v("When building a static version of the site "),n("code",[a._v("asyncData")]),a._v(" is invoked for each page and also bundled with each page so that subsequent invokations come with the "),n("code",[a._v("asyncDataSSR")]),a._v(" argument.")])])])])}),[],!1,null,null,null);"function"==typeof o&&o(p);s.default=p.exports}}]);